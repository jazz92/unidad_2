
<html>
  <head>
    <title> Estructura de la informacion</title>
        <style>
            h1{

                color:blue;
                font-size:200%
                }

            p{

          text-align:justify;
              
                
              }
            
           body
		   { background-image: url(blok.jpg);
background-size: 1600px 1200px;		   
                }  
           
            
            
            img{
                list-style-type:circle;
                width: 500px; height: 500px;
                }         
				img.double-border {
border: 5px solid #ddd;
padding: 5px; /*Inner border size*/
background: #fff; /*Inner border color*/
}
         </style>
    
  </head>
  <body>

﻿<html>
<head>
<title> Remedial unidad 2 y 3 </title>
	<h3 align="center"> ESTRUCTURA DE LA INFORMACION</h3>
<style>
		body{
		
		background-image : url(blok.jpg);
		background-repeat: no-repeat;
		background-size: 1400px 4800px;
		
		}
		img{display: block;
			margin: auto;
				}
			
		p{ margin : 0% 20% 10% 20%;
			text -align:justify;
			font-family: arial;}

</style>
</head>
<body>


    
<center>
				
					<li>introduccion</li>
					
				</ul></h2>
<p>

En su aspecto mas general, el arte de la programación de ordenadores ( 1.4) tiene mucho que ver con eso que llamamos la "inteligencia" humana; 
los procesos de abstraccion; la capacidad de imaginar un problema y sus posibles soluciones (hemos dicho que programar es formular la solucion de un problema).
 El proceso suele ir de lo general a lo particular y viceversa (de las ideas abstractas a los detalles concretos),
 en un proceso que se realimenta constantemente.
En una primera fase, el programador concibe una imagen del problema (el primer paso es "comprender el problema"),
 sin embargo, para formular la solución, se necesita un vehículo o soporte sobre el que construirla. En nuestro caso conocer un lenguaje de programacion, lo que en el fondo tiene un doble sentido: el primero y más importante, es conocer que herramientas ofrece. Estas herramientas funcionan como ideas-soporte; como ladrillos con los que construir la solución como si fuese una construccion material. Esto significa sobre todo, que el programador piensa en funcion de las herramientas disponibles. Sin ellas es incapaz de imaginarse ninguna solución concreta. El segundo significado es mucho menos importante (conceptualmente hablando); supone el conocimiento de una serie de reglas formales de utilizacion de los elementos del lenguaje. Sería la fase de mera codificacion, tarea para la que existen herramientas cada vez más eficaces. Por ejemplo, la amplia colección de herramientas RAD [1] que componen las modernas "suites" de desarrollo.La situación es comparable a la de un hipotetico Robinson que en una isla desierta tuviese que resolver el problema de su alojamiento. Tiene conciencia del problema y de su solución en abstracto: "un refugio". Sin embargo, para pensar algo concreto necesita antes explorar la isla, conocer que posibilidades ofrece. ¿Existen cuevas naturales?, ¿Madera?, ¿Restos de naufragios? ¿Algo que pueda adaptarse? etc. Evidentemente la forma mental de su refugio dependerá de los medios disponibles; posteriormente, la construcción en sí, será cuestión de detalle y de su propia habilidad manual.</p>
<p/>
<center>	
<h2>
			
				Datos y algoritmos
					
				</h2>

<br>
<br>

<p>informática, las ideas-soporte a que aludíamos son principalmente de dos tipos: Relativas a la información y a su manipulación (los datos y los algoritmos respectivamente).
En lo que concierne a los primeros (los datos), existen multitud de formas de organizarlos;  a estas formas las denominamos estructuras de datos. En cuanto a los segundos, existen un número casi infinito de algoritmos, pero en lo que aquí nos ocupa, tienen especial importancia los relacionados con el acceso a la información, es decir, los relacionados con su almacenamiento y recuperación. Algoritmos que Shildt denomina mecanismos de datos ( 2). Generalmente se considera que estos mecanismos realizan tres tipos de operaciones:  Inserción, borrado y búsqueda de la información en la estructura correspondiente.
Las estructuras y mecanismos de datos han sido muy estudiados;  constituyen en sí mismos dos mundos dentro de la informática, y dado que son las herramientas para construir un programa, además de la experiencia, es conveniente disponer del conjunto más completo posible de ellas (en este aspecto la programación se parece al bricolaje). Por ejemplo, si nos referimos a los algoritmos, los métodos de ordenación ("Sort") o de construcción de índices (que viene a ser equivalente), han sido muy estudiados, de forma que se conoce cuales son los más eficientes para cada caso (algunos incluso patentados). Si el lenguaje no los tiene preconstruidos, tendremos que fabricarlos manualmente con los medios disponibles. En este aspecto, un lenguaje es tanto mejor cuanto más abstractas sean las herramientas que nos ofrezca (estructuras y mecanismos de datos). Lo que significa que estarán más cercanas a la idea que tiene en mente el programador-humano y más alejadas de la forma concreta que adoptarán en la máquina. Este es precisamente el significado de la expresión "Lenguaje de alto o bajo nivel", el mayor o menor grado de proximidad que ofrezcan sus herramientas con las ideas (abstracciones) en la mente humana.
Al abordar un problema y decidirse por una estructura o mecanismo de datos concreto, hay un aspecto importante que debe ser conocido y tenido en cuenta por el programador. Es el hecho de que unas estructuras son más adecuadas para determinados mecanismos que otras. Dicho en otras palabras:  las relaciones entre las estructuras de datos y los algoritmos que las manipulan son muy significativas. Por ejemplo:  determinadas estructuras son muy adecuadas para operaciones de inserción y recuperación, de forma que los algoritmos que realizan estas operaciones son muy simples y rápidos. En cambio estas mismas estructuras pueden ser inadecuadas para buscar información en su interior. Resulta por tanto, que la relación de cada tipo de estructura de datos con los mecanismos básicos, inserción, borrado y búsqueda, es muy diferente, y debemos pensar detenidamente que relación tiene nuestra estructura con los mecanismos básicos (como la usaremos).
</p>

    <center><img  class="double-border" src="https://http2.mlstatic.com/estructura-de-la-informacion-juan-garcia-de-sola-mcgrawhill-D_NQ_NP_324601-MLA20355606286_072015-F.jpg" /></center>

</center>
		<center>		

				<br>
				<br>
					<h2>Estructura  Fisica y estructura Logica</li>
					
				</ul></h2>

<p>Al tratar de las estructuras y contenedores de datos, es conveniente tener algunas ideas básicas claras y precisas sobre los mecanismos involucrados.
La estructura lógica se corresponde con la idea que en principio tiene el programador sobre como están organizados los datos, y coincide aproximadamente con la forma en que son manipulados los datos por el programa de alto nivel.
En la concepción de la estructura lógica, el programador puede razonar más o menos en los siguientes términos:  "Voy a crear un fichero de clientes donde los datos de cada cliente estarán agrupados en un registro. Posteriormente accederé los registros por número de cliente (que será único) o por nombre, para lo que estarán ordenados alfabéticamente (construiré un índice con el código de cliente y otro de nombres)...".   Si está habituado a la programación de bases de datos con herramientas de alto nivel, quizás su razonamiento sea el siguiente:  "Voy a crear una tabla de clientes donde incluiré los datos de cada cliente, comenzando por una columna para el código que será el índice principal (será un INT UNSIGNED).  También crearé un campo "nombre" que será un VCHAR NOT NULL UNIQUE..."
En uno u otro caso, la estructura (se llame "fichero" o "tabla") es una unidad lógica que se compone una multitud de elementos individuales (se llamen "registros" o "filas" -según la cultura del programador-). La estructura así concebida tiene un orden, ya que sus elementos estarán conceptualmente uno detrás de otro. Este orden será numérico, si el acceso se realiza por código de cliente, o alfabético de nombres si el acceso se realiza por nombre. A su vez, esta estructura lógica se divide aún más finamente:  cada elemento se puede considerar dividido en multitud de campos. Aparte de los ya mencionados para código de cliente y nombre, pueden existir muchos mas:  dirección, teléfono, saldo, clasificación financiera, fecha última compra, vendedor asignado, etc. etc.
Por su parte, la estructura física corresponde a la forma en que están contenidos los datos en la máquina, de la que existen dos versiones:  una corresponde a la que adoptan los datos en memoria;  la otra a su almacenamiento externo (disco). Ambos esquemas son distintos.
Resulta evidente que la estructura física de datos en los almacenamientos externos no se corresponde exactamente con estructura lógica. En principio, el fichero o tabla de clientes antes mencionado, puede estar representado físicamente por varios ficheros que pueden ser multi-volumen. Es decir: ocupar más de un volumen lógico ( H8.1.2c1) en la máquina que los alberga. Si son aplicaciones de red, pueden estar incluso en máquinas remotas, distintas de la que ejecuta la aplicación. Además, aunque nos figuramos la estructura lógica es un todo continuo (suponemos que después de un cliente sigue otro), sabemos que la estructura física correspondiente, incluso si se trata solo de un fichero, está compuesta por trozos "clusters" que pueden estar dispersos en el disco.
La estructura lógica está ordenada (por números o por nombres en nuestro ejemplo). En cambio, la estructura física puede estar construida simplemente por el orden "natural" es decir, de creación de los propios registros. Generalmente, la "apariencia" de ordenación es el resultado de un proceso complejo que utiliza índices, tablas y punteros, para proporcionarnos un acceso ordenado a una estructura mucho más caótica.
</p>


</center>
  </body>

</html>
